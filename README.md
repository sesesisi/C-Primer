# c-grammar
c++ grammar
C++ 带符号和无符号char类型赋值超出表示范围的情况
在C++中字符型被分为了三种：char、signed char和unsigned char。需要的注意：

字符的表现形式只有两种：带符号的和无符号的，类型char具体使用哪一种由编译器决定；
如果需要使用不大的整数，应该明确指出它的类型是signed char或者unsigned char。
关于带符号类型：

带符号类型在表示范围内正值和负值的量应该平衡，例如，8比特理论上应该可以表示-127至127，大多数现代计算机将实际的表示范围定位-128至127；
当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined），程序可能继续工作、可能崩溃，也可能生成垃圾数据。
关于无符号类型：

无符号类型中所有比特都用来存储值，例如，8比特的unsigned char可以表示0至255区间内的值；
当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数（即取模后所得的数，并不是取余）。
例如：8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256（总数）取模后所得的余数。
因此，把-1赋给8比特大小的unsigned char所得的结果是255，使用2种方法计算：

有整数a和b，a对b进行取模或取余运算
1、求整数商：c=a/b
取模运算在计算商值向负无穷方向舍弃小数位
取余运算在计算商值向0方向舍弃小数位
2、计算模或者余数：r=a-(c*b)
注：取模运算遵循尽可能让商小，取余运算遵循尽可能让余数的绝对值小。因此，取模和取余的结果不同。

mod为取模，rem为取余，取模和取余所得的结果在a和b(同为整数) 符号相同 的时候是相等的


当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。但是当符号不一致的时候，结果不一样。

具体来说，求模运算结果的符号和b一致，求余运算结果的符号和a一致。


在本例中，将-1和256带入a和b，c=-1/256，向负无穷方向舍弃小数得-1，计算得r=255.

计算机中带符号的整数采用二进制的补码进行存储
正数的补码等于其二进制编码
负数的补码等于其绝对值的二进制编码，取反，再加1
在本例中，-1的绝对值是1，二进制编码为0000 0001，取反加1就是1111 1111
unsigned是无符号数，会把1111 1111看成正数，刚好是255的二进制编码。

Q：博主你这句话有点问题吧？？看的我有点困惑，望解答，谢谢！！！ mod为取模，rem为取余，取模和取余所得的数在a和b同为整数的时候是相等的，因为舍弃小数位时向负无穷和向0是同一个方向。 整数包括 正整数，负整数和 零 若 a / b 的商为负数，舍弃小数位时向负无穷和向0就不是同一个方向啦， 还有个问题想问博主，若 a/b 的商为 负整数 呢？（如 a/b = -2,那么舍弃小数位时向负无穷和向0的 结果都是 -2？ 还是其他数值呢？） 若 a/b 的商为 正整数 呢？（以 a/b =2 为例，那么舍弃小数位时向负无穷和向0的 结果？？）
A:若 a/b 的商为 负整数 呢？（如 a/b = -2,那么舍弃小数位时向负无穷和向0的 结果都是 -2？ 还是其他数值呢？） 若 a/b 的商为 正整数 呢？（以 a/b =2 为例，那么舍弃小数位时向负无穷和向0的 结果？？）” 你提出这个问题，你没理解这句话的含义： 取模运算在计算商值向负无穷方向舍弃小数位 取余运算在计算商值向0方向舍弃小数位 在第一个公式，需要根据上面2个规则计算c，也就是商值 比如4/-3 约等于-1.3，那么取模的话，c就是-2，取余的话c就是-1，你再计算取模，取余结果就分别是 -2，1 另一个例子6/-3,取模c等于-2，取余c也是-2，因为都可以被整除，那结果r就是0了
